<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
<title>EphemeralCypher â€” Hybrid Failover (AES-GCM / salt-iv / passphrase / pHash)</title>

<!-- PWA -->
<link rel="manifest" href="./manifest.json">
<meta name="theme-color" content="#111111">
<link rel="icon" href="./icon-192.png" type="image/png">
<link rel="apple-touch-icon" href="./icon-192.png">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

<style>
  :root { font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans JP", sans-serif; }
  body { margin:0; padding:18px; background:#fff; color:#111; }
  .card { max-width:860px; margin:0 auto; padding:18px; border:1px solid #e6e6e6; border-radius:14px; box-shadow:0 6px 22px rgba(0,0,0,.04); }
  h1 { margin:0 0 6px; font-size:1.15rem; }
  p.small { margin:6px 0 12px; color:#555; font-size:.95rem; }
  label { display:block; margin-top:12px; font-weight:600; }
  input[type=url], input[type=password], textarea, select {
    width:100%; box-sizing:border-box; padding:10px; border:1px solid #cfcfcf; border-radius:10px; margin-top:6px; font-size:1rem;
  }
  input[type=file]{ margin-top:8px; }
  textarea { min-height:120px; resize:vertical; }
  .row { display:flex; gap:10px; flex-wrap:wrap; }
  .row > * { flex:1; }
  .controls { display:flex; gap:10px; flex-wrap:wrap; margin-top:10px; }
  button { padding:10px 12px; border-radius:10px; border:1px solid #111; background:#fff; cursor:pointer; }
  .muted { color:#666; font-size:.92rem; }
  .status { margin-top:10px; font-size:.95rem; color:#111; }
  .warn { color:#a00; font-weight:700; }
  .tiny { font-size:.82rem; color:#555; }
  hr{ margin:16px 0; border:none; border-top:1px solid #eee; }
  .install { position: fixed; right: 12px; bottom: 12px; z-index: 10; }
</style>
</head>
<body>
<div class="card">
  <h1>EphemeralCypher</h1>
  <p class="small">HTMLã‚’éµæºã«ã—ãŸã€æš—å·ç”Ÿæˆãƒ»å¾©å·å™¨ã§ã™ã€‚</p>

  <label>éµã‚½ãƒ¼ã‚¹ï¼ˆURL ã¾ãŸã¯ãƒ­ãƒ¼ã‚«ãƒ« HTML ãƒ•ã‚¡ã‚¤ãƒ«ï¼‰</label>
  <input id="urlInput" type="url" placeholder="https://example.com/page.htmlï¼ˆç©ºæ¬„ãªã‚‰ä¸‹ã®ãƒ•ã‚¡ã‚¤ãƒ«å…¥åŠ›ã‚’å„ªå…ˆï¼‰">
  <input id="fileInput" type="file" accept=".html,.htm,.txt">

  <label>å…±æœ‰ãƒ‘ã‚¹ãƒ•ãƒ¬ãƒ¼ã‚ºï¼ˆæ¨å¥¨ãƒ»ç›¸æ‰‹ã¨å…±æœ‰ï¼‰</label>
  <input id="passphrase" type="password" placeholder="ä¾‹: word42 â€” ç©ºæ¬„ã¯å‹•ä½œå¯ã ãŒå…¬é–‹HTMLä¾å­˜ã§å±é™º">

  <div class="row">
    <div>
      <label>æš—å·åŒ–æ™‚ã®éµæ‹¡å¼µï¼ˆé¸æŠå¼ï¼‰</label>
      <select id="encryptMode">
        <option value="strict-html">å³æ ¼ï¼šHTMLã®ã¿</option>
        <option value="strict-img">å³æ ¼ï¼šHTML + æœ€åˆã® &lt;img&gt; ã®ç”Ÿãƒã‚¤ãƒˆ</option>
        <option value="phash">å¯›å®¹ï¼šHTML + æœ€åˆã® &lt;img&gt; ã® pHash(64bit)</option>
      </select>
      <div class="tiny muted">â€»ã€Œå³æ ¼ï¼šç”Ÿãƒã‚¤ãƒˆã€ã¯JPEGã®å†ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã§ä¸€è‡´ã—ãªããªã‚‹å¯èƒ½æ€§ã€‚å¯›å®¹pHashã¯è¿‘ä¼¼ä¸€è‡´ã«è€æ€§ã‚ã‚‹ãŒå®‰å…¨æ€§ã¯ç›¸å¯¾çš„ã«ä½ä¸‹ã€‚</div>
    </div>
    <div>
      <label>å¾©å·æ™‚ã®è‡ªå‹•è©¦è¡Œé †</label>
      <input id="tryStrictHtml" type="checkbox" checked> å³æ ¼(HTMLã®ã¿)
      <br><input id="tryStrictImg" type="checkbox" checked> å³æ ¼(HTML+ç”»åƒç”Ÿãƒã‚¤ãƒˆ)
      <br><input id="tryPHash" type="checkbox" checked> å¯›å®¹(HTML+pHash)
      <div class="tiny muted">ãƒã‚§ãƒƒã‚¯ã•ã‚ŒãŸé †ã«è‡ªå‹•è©¦è¡Œã—ã¾ã™ï¼ˆåˆæœŸã¯ â‘ HTMLã®ã¿ â†’ â‘¡HTML+ç”Ÿãƒã‚¤ãƒˆ â†’ â‘¢HTML+pHashï¼‰ã€‚</div>
    </div>
  </div>

  <label>ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ï¼ˆå¹³æ–‡ ã¾ãŸã¯ æš—å·æ–‡ base64ï¼‰</label>
  <textarea id="messageInput" placeholder="å¹³æ–‡ã‚’å…¥ã‚Œã¦æš—å·åŒ–ï¼æš—å·æ–‡ã‚’å…¥ã‚Œã¦å¾©å·"></textarea>

  <div class="controls">
    <button id="encryptBtn">ğŸ” æš—å·åŒ–</button>
    <button id="decryptBtn">ğŸ”“ å¾©å·ï¼ˆè‡ªå‹•ãƒ•ã‚§ã‚¤ãƒ«ã‚ªãƒ¼ãƒãƒ¼ï¼‰</button>
    <button id="pasteBtn">ğŸ“¥ è²¼ã‚Šä»˜ã‘â†’è‡ªå‹•åˆ¤å®š</button>
    <button id="copyBtn">ğŸ“‹ å‡ºåŠ›ã‚³ãƒ”ãƒ¼</button>
    <button id="clearBtn">ğŸ§¹ ã‚¯ãƒªã‚¢</button>
  </div>

  <label>å‡ºåŠ›</label>
  <textarea id="outputText" readonly placeholder="çµæœãŒã“ã“ã«è¡¨ç¤ºã•ã‚Œã¾ã™"></textarea>

  <div id="status" class="status muted">æº–å‚™å®Œäº†</div>

  <hr>
  <p class="warn">æ³¨æ„</p>
  <ul class="muted">
    <li>å…¬é–‹ãƒšãƒ¼ã‚¸ã®ã¿ã‚’éµã«ã™ã‚‹ã®ã¯å±é™ºã§ã™ã€‚<b>passphrase</b>ã®ä½µç”¨ã‚’å¼·ãæ¨å¥¨ã€‚</li>
    <li>å³æ ¼ï¼ˆç”Ÿãƒã‚¤ãƒˆï¼‰ã¯æœ€ã‚‚å¼·å›ºã§ã™ãŒã€JPEGã®å†ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã‚„CDNæœ€é©åŒ–ã§ä¸€è‡´ã—ãªã„ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚</li>
    <li>å¯›å®¹ï¼ˆpHashï¼‰ã¯è¿‘ä¼¼ä¸€è‡´ã«å¼·ã„ä»£ã‚ã‚Šã«ã€ç·å½“ãŸã‚Šè€æ€§ãŒç›¸å¯¾çš„ã«ä¸‹ãŒã‚Šã¾ã™ï¼ˆå¿…ãš salt/IV/passphrase ã¨ä½µç”¨ï¼‰ã€‚</li>
  </ul>
</div>

<!-- ====== ã‚¢ãƒ—ãƒªæœ¬ä½“ï¼ˆã‚ãªãŸã®ãƒ­ã‚¸ãƒƒã‚¯ï¼‰ ====== -->
<script>
const enc = new TextEncoder(), dec = new TextDecoder();
const statusEl = document.getElementById('status');
const urlInput = document.getElementById('urlInput');
const fileInput = document.getElementById('fileInput');
const passInput = document.getElementById('passphrase');
const encryptModeSel = document.getElementById('encryptMode');
const tryStrictHtmlCb = document.getElementById('tryStrictHtml');
const tryStrictImgCb  = document.getElementById('tryStrictImg');
const tryPHashCb      = document.getElementById('tryPHash');
const msgInput = document.getElementById('messageInput');
const outText  = document.getElementById('outputText');

function setStatus(txt, warn=false){ statusEl.textContent = txt; statusEl.style.color = warn ? '#a00' : '#111'; }
function toB64(bytes){ return btoa(String.fromCharCode(...bytes)); }
function fromB64(str){ return new Uint8Array(atob(str).split('').map(c=>c.charCodeAt(0))); }
async function sha256Bytes(bytes){ return new Uint8Array(await crypto.subtle.digest('SHA-256', bytes)); }

function normalizeHtmlText(text){
  if (!text) return "";
  if (text.charCodeAt(0) === 0xFEFF) text = text.slice(1);
  text = text.replace(/^\s*<!doctype[^>]*>/i, '');
  text = text.replace(/^\s*<\?xml[^>]*\?>/i, '');
  return text.trim();
}

async function fetchTextViaProxy(url){
  const proxy = 'https://api.allorigins.win/raw?url=' + encodeURIComponent(url);
  const res = await fetch(proxy, { cache:'no-store' });
  if (!res.ok) throw new Error('ãƒšãƒ¼ã‚¸å–å¾—å¤±æ•—: ' + res.status);
  return await res.text();
}

async function getBaseHashHTML(){
  const file = fileInput.files[0];
  const url  = urlInput.value.trim();
  if (file){
    const t = await readFileText(file);
    return await sha256Bytes(enc.encode(normalizeHtmlText(t)));
  } else if (url){
    const raw = await fetchTextViaProxy(url);
    return await sha256Bytes(enc.encode(normalizeHtmlText(raw)));
  }
  throw new Error('URL ã‹ ãƒ•ã‚¡ã‚¤ãƒ« ã‚’æŒ‡å®šã—ã¦ãã ã•ã„');
}

function readFileText(file){
  return new Promise((resolve,reject)=>{
    const r = new FileReader();
    r.onload = e => resolve(String(e.target.result||""));
    r.onerror = ()=> reject(new Error('ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼'));
    r.readAsText(file);
  });
}

async function getFirstImageURLFromHtml(rawHtml, baseUrl){
  try{
    const doc = new DOMParser().parseFromString(rawHtml, 'text/html');
    const img = doc.querySelector('img');
    if (!img || !img.src) return null;
    const a = document.createElement('a');
    a.href = img.src;
    if (!a.host && baseUrl){
      const u = new URL(baseUrl);
      return new URL(img.src, u).toString();
    }
    return img.src;
  }catch(e){ return null; }
}

async function fetchImageBlobViaProxy(imgUrl){
  const res = await fetch('https://api.allorigins.win/raw?url=' + encodeURIComponent(imgUrl), { cache:'no-store' });
  if (!res.ok) throw new Error('ç”»åƒå–å¾—å¤±æ•—: ' + res.status);
  return await res.blob();
}

async function imageBitmapFromBlob(blob){
  if ('createImageBitmap' in window){
    try { return await createImageBitmap(blob); } catch(e){}
  }
  return await new Promise((resolve,reject)=>{
    const url = URL.createObjectURL(blob);
    const img = new Image();
    img.onload = ()=>{ resolve(img); URL.revokeObjectURL(url); };
    img.onerror = ()=>{ reject(new Error('ç”»åƒãƒ‡ã‚³ãƒ¼ãƒ‰å¤±æ•—')); URL.revokeObjectURL(url); };
    img.src = url;
  });
}

function getCanvasCtx(w,h){
  const c = document.createElement('canvas');
  c.width = w; c.height = h;
  const ctx = c.getContext('2d', { willReadFrequently:true });
  return { canvas: c, ctx };
}

function dct2dFloat(Y, N){
  const C = new Float32Array(N*N);
  const pi = Math.PI, invN = 1/Math.sqrt(N);
  const alpha = (k)=> k===0 ? invN : Math.sqrt(2/N);
  const tmp = new Float32Array(N*N);
  for (let y=0;y<N;y++){
    for (let u=0;u<N;u++){
      let sum=0;
      for (let x=0;x<N;x++){
        sum += Y[y*N+x]*Math.cos(((2*x+1)*u*pi)/(2*N));
      }
      tmp[y*N+u] = alpha(u)*sum;
    }
  }
  for (let u=0;u<N;u++){
    for (let v=0;v<N;v++){
      let sum=0;
      for (let y=0;y<N;y++){
        sum += tmp[y*N+u]*Math.cos(((2*y+1)*v*pi)/(2*N));
      }
      C[v*N+u] = alpha(v)*sum;
    }
  }
  return C;
}

async function computeImagePHashBytesFromBlob(blob){
  const bmp = await imageBitmapFromBlob(blob);
  const size = 32;
  const {canvas,ctx} = getCanvasCtx(size, size);
  ctx.drawImage(bmp, 0, 0, size, size);
  const imgData = ctx.getImageData(0,0,size,size).data;
  const Y = new Float32Array(size*size);
  for (let i=0, j=0; i<imgData.length; i+=4, j++){
    const r=imgData[i], g=imgData[i+1], b=imgData[i+2];
    Y[j] = 0.299*r + 0.587*g + 0.114*b;
  }
  const D = dct2dFloat(Y, size);
  const block = [];
  for (let v=0; v<8; v++){
    for (let u=0; u<8; u++){
      block.push(D[v*size + u]);
    }
  }
  const mean = block.slice(1).reduce((a,b)=>a+b,0)/(block.length-1);
  let bits = 0n;
  for (let k=0;k<64;k++){
    bits = (bits<<1n) | (block[k] > mean ? 1n : 0n);
  }
  const phash = new Uint8Array(8);
  for (let i=7;i>=0;i--){ phash[i] = Number(bits & 0xFFn); bits >>= 8n; }
  return phash;
}

async function deriveAesKey(baseHashHTML, passphrase, saltBytes, extraBytes){
  const passB = new TextEncoder().encode(passphrase || "");
  const total = new Uint8Array(baseHashHTML.length + passB.length + saltBytes.length + (extraBytes?extraBytes.length:0));
  let off=0;
  total.set(baseHashHTML, off); off += baseHashHTML.length;
  total.set(passB, off);        off += passB.length;
  total.set(saltBytes, off);    off += saltBytes.length;
  if (extraBytes){ total.set(extraBytes, off); }
  const keyBytes = await crypto.subtle.digest('SHA-256', total).then(buf=>new Uint8Array(buf));
  return await crypto.subtle.importKey('raw', keyBytes, {name:'AES-GCM'}, false, ['encrypt','decrypt']);
}

async function encryptAesGcm(plainBytes, key, iv){
  return new Uint8Array(await crypto.subtle.encrypt({name:'AES-GCM', iv}, key, plainBytes));
}
async function decryptAesGcm(ctBytes, key, iv){
  return new Uint8Array(await crypto.subtle.decrypt({name:'AES-GCM', iv}, key, ctBytes));
}

async function buildStrictImageBytes(url){
  const raw = await fetchTextViaProxy(url);
  const imgUrl = await getFirstImageURLFromHtml(raw, url);
  if (!imgUrl) return null;
  const blob = await fetchImageBlobViaProxy(imgUrl);
  const ab = await blob.arrayBuffer();
  return new Uint8Array(ab);
}

async function buildPHashBytes(url){
  const raw = await fetchTextViaProxy(url);
  const imgUrl = await getFirstImageURLFromHtml(raw, url);
  if (!imgUrl) return null;
  const blob = await fetchImageBlobViaProxy(imgUrl);
  return await computeImagePHashBytesFromBlob(blob);
}

async function encryptFlow(){
  try{
    setStatus('éµç´ æå–å¾—ä¸­...');
    const baseHash = await getBaseHashHTML();
    const pass = passInput.value || "";
    if (!pass) setStatus('è­¦å‘Š: passphrase ãŒç©ºæ¬„ã§ã™ï¼ˆå…¬é–‹HTMLä¾å­˜ã¯å±é™ºï¼‰', true);

    const mode = encryptModeSel.value;
    let extra = null;

    if (mode === 'strict-img'){
      const url = urlInput.value.trim();
      if (!url) throw new Error('ã€Œå³æ ¼ï¼šHTML+ç”»åƒç”Ÿãƒã‚¤ãƒˆã€ã¯URLãƒšãƒ¼ã‚¸ãŒå¿…è¦ã§ã™ï¼ˆãƒ•ã‚¡ã‚¤ãƒ«å†…ã®<img>ã¯éå¯¾å¿œï¼‰');
      extra = await buildStrictImageBytes(url);
      if (!extra) throw new Error('ãƒšãƒ¼ã‚¸å†…ã®æœ€åˆã®<img>ãŒè¦‹ã¤ã‹ã‚‰ãªã„/å–å¾—ä¸å¯ã§ã—ãŸ');
    } else if (mode === 'phash'){
      const url = urlInput.value.trim();
      if (!url) throw new Error('ã€Œå¯›å®¹ï¼špHashã€ã¯URLãƒšãƒ¼ã‚¸ãŒå¿…è¦ã§ã™ï¼ˆãƒ•ã‚¡ã‚¤ãƒ«å†…ã®<img>ã¯éå¯¾å¿œï¼‰');
      extra = await buildPHashBytes(url);
      if (!extra) throw new Error('ãƒšãƒ¼ã‚¸å†…ã®æœ€åˆã®<img>ãŒè¦‹ã¤ã‹ã‚‰ãªã„/å–å¾—ä¸å¯ã§ã—ãŸï¼ˆpHashç”Ÿæˆä¸å¯ï¼‰');
    }

    const salt = crypto.getRandomValues(new Uint8Array(12));
    const iv   = crypto.getRandomValues(new Uint8Array(12));
    const key  = await deriveAesKey(baseHash, pass, salt, extra);

    const pt = new TextEncoder().encode(msgInput.value||"");
    if (!pt.length) throw new Error('æš—å·åŒ–ã™ã‚‹ãƒ†ã‚­ã‚¹ãƒˆã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');

    setStatus('æš—å·åŒ–ä¸­...');
    const ct = await encryptAesGcm(pt, key, iv);
    const out = new Uint8Array(salt.length + iv.length + ct.length);
    out.set(salt,0); out.set(iv,12); out.set(ct,24);
    outText.value = btoa(String.fromCharCode(...out));
    setStatus('âœ… æš—å·åŒ–å®Œäº†');
  }catch(e){
    outText.value = '';
    setStatus('ğŸ”´ æš—å·åŒ–å¤±æ•—: ' + (e.message||e), true);
  }
}

async function decryptFlow(){
  try{
    const input = (msgInput.value||"").trim();
    if (!input) throw new Error('å¾©å·ã™ã‚‹ base64 ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');
    const data = new Uint8Array(atob(input.replace(/\s+/g,'')).split('').map(c=>c.charCodeAt(0)));
    if (data.length < 24) throw new Error('å…¥åŠ›ãŒçŸ­ã™ãã¾ã™');
    const salt = data.slice(0,12);
    const iv   = data.slice(12,24);
    const ct   = data.slice(24);

    setStatus('éµç´ æï¼ˆHTMLãƒãƒƒã‚·ãƒ¥ï¼‰å–å¾—ä¸­...');
    const baseHash = await getBaseHashHTML();
    const pass = passInput.value || "";

    const url = urlInput.value.trim();
    const tryList = [];

    if (tryStrictHtmlCb.checked){
      tryList.push({ name:'å³æ ¼:HTMLã®ã¿', buildExtra: async()=>null });
    }
    if (tryStrictImgCb.checked && url){
      tryList.push({ name:'å³æ ¼:HTML+ç”»åƒç”Ÿãƒã‚¤ãƒˆ', buildExtra: async()=> await buildStrictImageBytes(url) });
    }
    if (tryPHashCb.checked && url){
      tryList.push({ name:'å¯›å®¹:HTML+pHash', buildExtra: async()=> await buildPHashBytes(url) });
    }
    if (tryList.length === 0) throw new Error('è©¦è¡Œãƒ¢ãƒ¼ãƒ‰ãŒå…¨ã¦ç„¡åŠ¹ã§ã™ã€‚å³å´ã®ãƒã‚§ãƒƒã‚¯ã‚’æœ‰åŠ¹ã«ã—ã¦ãã ã•ã„ã€‚');

    let lastErr = null;
    for (const cand of tryList){
      try{
        setStatus('éµå°å‡ºâ†’å¾©å·è©¦è¡Œä¸­: ' + cand.name + ' ...');
        const extra = await cand.buildExtra();
        const key   = await deriveAesKey(baseHash, pass, salt, extra||null);
        const pt    = await decryptAesGcm(ct, key, iv);
        outText.value = new TextDecoder().decode(pt);
        setStatus('âœ… å¾©å·æˆåŠŸ: ' + cand.name);
        return;
      }catch(err){
        lastErr = err;
      }
    }
    throw lastErr || new Error('å…¨ã¦ã®å€™è£œã§å¾©å·ã«å¤±æ•—ã—ã¾ã—ãŸ');
  }catch(e){
    outText.value = '';
    setStatus('ğŸ”´ å¾©å·å¤±æ•—: ' + (e.message||e), true);
  }
}

document.getElementById('encryptBtn').addEventListener('click', encryptFlow);
document.getElementById('decryptBtn').addEventListener('click', decryptFlow);
document.getElementById('pasteBtn').addEventListener('click', async ()=>{
  try{
    const txt = await navigator.clipboard.readText();
    if (!txt){ setStatus('ğŸ“‹ ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«æ–‡å­—ãŒã‚ã‚Šã¾ã›ã‚“', true); return; }
    msgInput.value = txt;
    const v = txt.trim();
    if (/^[A-Za-z0-9+/=\s]+$/.test(v) && v.replace(/\s+/g,'').length>24){
      setStatus('Base64æ¤œå‡ºâ†’å¾©å·ï¼ˆè‡ªå‹•è©¦è¡Œï¼‰ã‚’å®Ÿè¡Œ'); await decryptFlow();
    }else{
      setStatus('ãƒ†ã‚­ã‚¹ãƒˆæ¤œå‡ºâ†’æš—å·åŒ–ã‚’å®Ÿè¡Œ'); await encryptFlow();
    }
  }catch(e){ setStatus('âŒ ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰èª­ã¿å–ã‚Šå¤±æ•—: ' + (e.message||e), true); }
});
document.getElementById('copyBtn').addEventListener('click', ()=>{
  outText.select(); document.execCommand('copy'); setStatus('ğŸ“‹ å‡ºåŠ›ã‚’ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸ');
});
document.getElementById('clearBtn').addEventListener('click', ()=>{
  msgInput.value=''; outText.value=''; setStatus('å…¥åŠ›ã‚’ã‚¯ãƒªã‚¢ã—ã¾ã—ãŸ');
});

setStatus('æº–å‚™å®Œäº† â€” URLã‹ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æŒ‡å®šã—ã€å¿…è¦ãªã‚‰passphraseã‚’å…¥ã‚Œã¦æš—å·åŒ–/å¾©å·ã—ã¦ãã ã•ã„ã€‚');
</script>

<!-- Service Worker ç™»éŒ²ï¼ˆã‚¹ã‚³ãƒ¼ãƒ—æ˜ç¤º & 1å›å†èª­è¾¼ã§åˆ¶å¾¡ä¸‹ã¸ï¼‰ -->
<button id="installBtn" class="install">â¬‡ï¸ ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«</button>
<script>
let deferredPrompt = null;

if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('./sw.js', { scope: './' })
    .then(() => console.log('SW registered'))
    .catch(console.error);
}

window.addEventListener('beforeinstallprompt', (e) => {
  e.preventDefault();
  deferredPrompt = e;
  document.getElementById('installBtn').style.display = 'inline-block';
});

document.getElementById('installBtn').addEventListener('click', async () => {
  if (!deferredPrompt) return;
  deferredPrompt.prompt();
  const { outcome } = await deferredPrompt.userChoice;
  console.log('PWA install:', outcome);
  deferredPrompt = null;
  document.getElementById('installBtn').style.display = 'none';
});
</script>
</body>
</html>
