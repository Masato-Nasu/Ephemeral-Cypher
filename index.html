<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>EphemeralCypher</title>
<link rel="manifest" href="./manifest.json">
<link rel="icon" href="./icon-192.png" type="image/png">
<meta name="theme-color" content="#0b0b0f">
<style>
  :root{
    --bg:#0b0b0f;
    --card:#12121a;
    --card2:#151523;
    --text:#f2f2f7;
    --muted:rgba(242,242,247,.62);
    --line:rgba(255,255,255,.09);
    --accent:#b9a7ff;
    --danger:#ff6b6b;
  }
  *{box-sizing:border-box}
  body{
    margin:0;
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    background: radial-gradient(1200px 600px at 20% -10%, rgba(185,167,255,.18), transparent 55%),
                radial-gradient(900px 500px at 100% 0%, rgba(255,255,255,.08), transparent 55%),
                var(--bg);
    color:var(--text);
  }
  .wrap{max-width:860px;margin:0 auto;padding:28px 18px 42px}
  .hero{
    display:flex;align-items:center;gap:12px;margin-bottom:18px
  }
  .logo{
    width:40px;height:40px;border-radius:14px;
    background: linear-gradient(145deg, rgba(185,167,255,.26), rgba(255,255,255,.06));
    border:1px solid var(--line);
    display:grid;place-items:center;
    box-shadow: 0 12px 32px rgba(0,0,0,.35);
  }
  .title{font-size:18px;font-weight:700;letter-spacing:.2px;margin:0}
  .sub{margin:2px 0 0 0;color:var(--muted);font-size:13px}
  .card{
    background: linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.01));
    border:1px solid var(--line);
    border-radius:18px;
    padding:16px;
    box-shadow: 0 16px 50px rgba(0,0,0,.35);
  }
  .grid{display:grid;gap:14px}
  @media (min-width: 860px){ .grid.cols2{grid-template-columns: 1fr 1fr;} }
  label{display:block;font-size:12px;color:var(--muted);margin:0 0 8px 2px}
  input[type="text"], textarea, input[type="file"]{
    width:100%;
    background: rgba(255,255,255,.03);
    border:1px solid var(--line);
    color:var(--text);
    border-radius:14px;
    padding:12px 12px;
    outline:none;
  }
  input[type="file"]{padding:10px}
  textarea{min-height:132px;resize:vertical;line-height:1.5}
  .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  .btn{
    border-radius:14px;border:1px solid var(--line);
    padding:12px 14px;background: rgba(255,255,255,.04);
    color:var(--text);font-weight:700;cursor:pointer;
    transition: transform .06s ease, background .2s ease, border-color .2s ease;
    user-select:none;
  }
  .btn:hover{background: rgba(255,255,255,.06);border-color: rgba(255,255,255,.14)}
  .btn:active{transform: translateY(1px)}
  .btn.primary{
    background: linear-gradient(145deg, rgba(185,167,255,.34), rgba(255,255,255,.06));
    border-color: rgba(185,167,255,.32);
  }
  .btn.danger{border-color: rgba(255,107,107,.35); background: rgba(255,107,107,.08)}
  .btn:disabled{opacity:.45;cursor:not-allowed;transform:none}
  .chip{
    font-size:12px; padding:6px 10px;border-radius:999px;
    border:1px solid var(--line); color:var(--muted); background: rgba(255,255,255,.02);
  }
  .chip.on{color:rgba(242,242,247,.92); border-color: rgba(185,167,255,.35); background: rgba(185,167,255,.10)}
  .status{margin-top:10px;font-size:12px;color:var(--muted)}
  .status.err{color: var(--danger)}
  .hr{height:1px;background: var(--line); margin: 14px 0}
  .mini{font-size:12px;color:var(--muted);margin: 8px 2px 0}
  .right{margin-left:auto}
</style>
</head>
<body>
<div class="wrap">
  <div class="hero">
    <div class="logo" aria-hidden="true">
      <svg width="22" height="22" viewBox="0 0 24 24" fill="none">
        <path d="M7 11V8.5C7 5.462 9.462 3 12.5 3C15.538 3 18 5.462 18 8.5V11" stroke="white" stroke-opacity=".9" stroke-width="1.6" stroke-linecap="round"/>
        <path d="M6.6 11H17.4C18.28 11 19 11.72 19 12.6V18.4C19 19.28 18.28 20 17.4 20H6.6C5.72 20 5 19.28 5 18.4V12.6C5 11.72 5.72 11 6.6 11Z" stroke="white" stroke-opacity=".9" stroke-width="1.6"/>
        <path d="M12 14V17" stroke="white" stroke-opacity=".9" stroke-width="1.8" stroke-linecap="round"/>
      </svg>
    </div>
    <div>
      <p class="title">EphemeralCypher</p>
      <p class="sub">éµç´ æï¼ˆHTML ã¾ãŸã¯ ç”»åƒï¼‰ã¨ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã ã‘ã€‚ä½™è¨ˆãªè¨­å®šã¯ã‚ã‚Šã¾ã›ã‚“ã€‚</p>
    </div>
  </div>

  <div class="card grid cols2">
    <div>
      <label>éµç´ æï¼šURLï¼ˆä»»æ„ï¼‰</label>
      <input id="urlInput" type="text" inputmode="url" placeholder="https://example.com/page.html">
      <div id="urlWarn" class="mini" style="display:none;color:var(--danger)">â€» URLã ã‘ã‚’éµã«ã™ã‚‹ã¨ã€åŒã˜URLã«ã‚¢ã‚¯ã‚»ã‚¹ã§ãã‚‹äººã¯å¾©å·ã§ãã¾ã™ã€‚</div>
    </div>
    <div class="row" style="align-content:flex-end">
      <span id="chipHtml" class="chip">HTML: æœªé¸æŠ</span>
      <span id="chipImg" class="chip">ç”»åƒ: æœªé¸æŠ</span>
      <span class="right"></span>
    </div>

    <div>
      <label>éµç´ æï¼šHTMLãƒ•ã‚¡ã‚¤ãƒ«ï¼ˆä»»æ„ï¼‰</label>
      <input id="fileInput" type="file" accept=".html,text/html">
    </div>

    <div>
      <label>éµç´ æï¼šç”»åƒãƒ•ã‚¡ã‚¤ãƒ«ï¼ˆä»»æ„ï¼‰</label>
      <input id="imgInput" type="file" accept="image/*">
      <div class="mini">â€» ç”»åƒéµã¯ã‚³ãƒ”ãƒ¼/å†ä¿å­˜ã§ã‚‚å‹•ãã‚„ã™ã„æ–¹å¼ã§ã™ï¼ˆå¤§ããªç·¨é›†ãƒ»ãƒˆãƒªãƒŸãƒ³ã‚°ãƒ»è§£åƒåº¦å¤‰æ›´ãŒå¤§ãã„ã¨å¤±æ•—ã™ã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ï¼‰ã€‚</div>
    </div>

    <div style="grid-column: 1 / -1;">
      <div class="hr"></div>
      <label>ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ï¼ˆå¹³æ–‡ ã¾ãŸã¯ æš—å·æ–‡ base64ï¼‰</label>
      <textarea id="messageInput" placeholder="ã“ã“ã«å…¥åŠ›"></textarea>
      <div class="row" style="margin-top:10px">
        <button id="encryptBtn" class="btn primary">ğŸ” æš—å·åŒ–</button>
        <button id="decryptBtn" class="btn">ğŸ”“ å¾©å·</button>
        <button id="copyBtn" class="btn">ğŸ“‹ å‡ºåŠ›ã‚³ãƒ”ãƒ¼</button>
        <button id="clearBtn" class="btn danger">ğŸ§¹ ã‚¯ãƒªã‚¢</button>
      </div>

      <label style="margin-top:12px">å‡ºåŠ›</label>
      <textarea id="outputText" readonly placeholder="çµæœ"></textarea>

      <div id="status" class="status">æº–å‚™å®Œäº†</div>
    </div>
  </div>
</div>

<script>
// ===== åŸºæœ¬ =====
const enc = new TextEncoder(), dec = new TextDecoder();
const urlInput = document.getElementById('urlInput');
const fileInput = document.getElementById('fileInput');
const imgInput  = document.getElementById('imgInput');
const msgInput  = document.getElementById('messageInput');
const outText   = document.getElementById('outputText');
const statusEl  = document.getElementById('status');
const urlWarn   = document.getElementById('urlWarn');

const chipHtml  = document.getElementById('chipHtml');
const chipImg   = document.getElementById('chipImg');

const encryptBtn = document.getElementById('encryptBtn');
const decryptBtn = document.getElementById('decryptBtn');
const copyBtn    = document.getElementById('copyBtn');
const clearBtn   = document.getElementById('clearBtn');

function setStatus(msg, isErr=false){
  statusEl.textContent = msg;
  statusEl.className = 'status' + (isErr ? ' err' : '');
}

function b64encode(u8){
  let s = '';
  const chunk = 0x8000;
  for (let i=0;i<u8.length;i+=chunk){
    s += String.fromCharCode(...u8.subarray(i, i+chunk));
  }
  return btoa(s);
}
function b64decode(b64){
  const bin = atob((b64||'').trim());
  const u8 = new Uint8Array(bin.length);
  for (let i=0;i<bin.length;i++) u8[i] = bin.charCodeAt(i);
  return u8;
}

function concatBytes(...arrs){
  const len = arrs.reduce((a,b)=>a+(b?b.length:0),0);
  const out = new Uint8Array(len);
  let off=0;
  for (const a of arrs){
    if (!a) continue;
    out.set(a, off); off += a.length;
  }
  return out;
}

async function sha256Bytes(bytes){
  const buf = await crypto.subtle.digest('SHA-256', bytes);
  return new Uint8Array(buf);
}

function stableHtmlText(html){
  try{
    const doc = new DOMParser().parseFromString(html, 'text/html');
    // remove noisy nodes
    doc.querySelectorAll('script,style,noscript,template').forEach(n=>n.remove());

    const title = (doc.querySelector('title')?.textContent || '').trim();
    const ogt   = (doc.querySelector('meta[property="og:title"]')?.getAttribute('content') || '').trim();
    const desc  = (doc.querySelector('meta[name="description"]')?.getAttribute('content') || '').trim();
    const canon = (doc.querySelector('link[rel="canonical"]')?.getAttribute('href') || '').trim();

    const body = doc.body ? (doc.body.innerText || doc.body.textContent || '') : '';
    let t = [title, ogt, desc, canon, body].filter(Boolean).join('\n');

    // normalize
    t = t.replace(/\r\n?/g,'\n');
    t = t.replace(/<!--[\s\S]*?-->/g, '');
    t = t.replace(/^\s*<\?xml[^>]*\?>/i, '');
    t = t.replace(/\s+/g,' ').trim();

    // cap to keep it fast & stable
    if (t.length > 200000) t = t.slice(0, 200000);
    return t;
  }catch(e){
    // fallback: minimal normalization
    let t = String(html || '').replace(/\r\n?/g,'\n');
    t = t.replace(/<!--[\s\S]*?-->/g, '');
    t = t.replace(/^\s*<\?xml[^>]*\?>/i, '');
    t = t.replace(/\s+/g,' ').trim();
    if (t.length > 200000) t = t.slice(0, 200000);
    return t;
  }
}


async function readFileText(file){
  return new Promise((resolve,reject)=>{
    const r = new FileReader();
    r.onload = ()=> resolve(r.result || '');
    r.onerror = ()=> reject(new Error('ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼'));
    r.readAsText(file);
  });
}

async function fetchTextViaProxy(url){
  const proxy = 'https://r.jina.ai/http' + (url.startsWith('https://') ? 's' : '') + '://' + url.replace(/^https?:\/\//,'');
  const ac = new AbortController();
  const timer = setTimeout(()=>ac.abort(), 9000);
  try{
    const res = await fetch(proxy, { cache:'no-store', signal: ac.signal });
    if (!res.ok) throw new Error('ãƒšãƒ¼ã‚¸å–å¾—å¤±æ•—: ' + res.status);
    return await res.text();
  }catch(e){
    if (e && e.name === 'AbortError') throw new Error('ãƒšãƒ¼ã‚¸å–å¾—ãŒã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã—ã¾ã—ãŸ');
    throw e;
  }finally{
    clearTimeout(timer);
  }
}


async function fetchImageBlobViaProxy(url){
  const proxy = 'https://api.allorigins.win/raw?url=' + encodeURIComponent(url);
  const res = await fetch(proxy, { cache:'no-store' });
  if (!res.ok) throw new Error('ç”»åƒå–å¾—å¤±æ•—: ' + res.status);
  return await res.blob();
}

async function getFirstImageURLFromHtml(rawHtml, baseUrl){
  try{
    const doc = new DOMParser().parseFromString(rawHtml, 'text/html');
    const img = doc.querySelector('img');
    if (!img || !img.src) return null;
    const u = new URL(img.src, baseUrl);
    return u.toString();
  }catch(e){
    return null;
  }
}

// ===== éµç´ æã®å–å¾— =====
async function getHtmlHash(){
  const f = fileInput.files[0];
  const url = urlInput.value.trim();
  if (f){
    const t = await readFileText(f);
    return await sha256Bytes(enc.encode(stableHtmlText(t)));
  }
  if (url){
    const raw = await fetchTextViaProxy(url);
    return await sha256Bytes(enc.encode(stableHtmlText(raw)));
  }
  return null;
}

async function imageKeyHashFromBlob(blob){
  // è¦‹ãŸç›®ãƒ™ãƒ¼ã‚¹ã®ãƒãƒƒã‚·ãƒ¥ï¼ˆå†ä¿å­˜ãƒ»ã‚³ãƒ”ãƒ¼ã§ãƒã‚¤ãƒˆåˆ—ãŒå¤‰ã‚ã£ã¦ã‚‚ä¸€è‡´ã—ã‚„ã™ã„ï¼‰
  const a = await aHash64(blob); // 8 bytes
  const d = await dHash64(blob); // 8 bytes
  return await sha256Bytes(concatBytes(new Uint8Array([0x41,0x44]), a, d)); // 'A''D'
}

function packBits64ToBytes(bits){
  // bits: Array<boolean> length 64
  const out = new Uint8Array(8);
  for (let i=0;i<64;i++){
    if (bits[i]) out[i>>3] |= (1 << (7-(i&7)));
  }
  return out;
}

async function aHash64(blob){
  const w=8,h=8;
  const {data} = await drawImageToRGBA(blob, w, h);
  const gray = new Float32Array(w*h);
  let sum=0;
  for (let i=0;i<w*h;i++){
    const r=data[i*4], g=data[i*4+1], b=data[i*4+2];
    const v = 0.299*r + 0.587*g + 0.114*b;
    gray[i]=v; sum+=v;
  }
  const avg = sum/(w*h);
  const bits = new Array(64);
  for (let i=0;i<64;i++) bits[i] = gray[i] >= avg;
  return packBits64ToBytes(bits);
}

async function dHash64(blob){
  const w=9,h=8;
  const {data} = await drawImageToRGBA(blob, w, h);
  const bits = new Array(64);
  let k=0;
  for (let y=0;y<h;y++){
    for (let x=0;x<w-1;x++){
      const i1=(y*w+x)*4, i2=(y*w+(x+1))*4;
      const g1 = 0.299*data[i1] + 0.587*data[i1+1] + 0.114*data[i1+2];
      const g2 = 0.299*data[i2] + 0.587*data[i2+1] + 0.114*data[i2+2];
      bits[k++] = g1 > g2;
    }
  }
  return packBits64ToBytes(bits);
}

async function drawImageToRGBA(blob, w, h){
  const bmp = await createImageBitmap(blob);
  try{
    const c = document.createElement('canvas');
    c.width = w; c.height = h;
    const ctx = c.getContext('2d', { willReadFrequently:true });
    ctx.clearRect(0,0,w,h);
    ctx.drawImage(bmp, 0, 0, w, h);
    const img = ctx.getImageData(0,0,w,h);
    return { data: img.data };
  }finally{
    try{ bmp.close(); }catch(e){}
  }
}

async function getImageHash(){
  const f = imgInput.files[0];
  if (f){
    return await imageKeyHashFromBlob(f);
  }
  return null;
}



async function buildBaseKey(){
  const htmlHash = await getHtmlHash();
  const imgHash  = await getImageHash();

  const parts = [];
  if (htmlHash) parts.push(concatBytes(new Uint8Array([0x48]), htmlHash)); // 'H'
  if (imgHash)  parts.push(concatBytes(new Uint8Array([0x49]), imgHash)); // 'I'

  if (parts.length === 0) throw new Error('éµç´ æãŒã‚ã‚Šã¾ã›ã‚“ï¼ˆURL / HTML / ç”»åƒ ã®ã„ãšã‚Œã‹ã‚’æŒ‡å®šã—ã¦ãã ã•ã„ï¼‰');

  // URLã ã‘ã®ã¨ãã¯æ³¨æ„ï¼ˆå…¬é–‹ç´ æ = èª°ã§ã‚‚å†ç¾å¯èƒ½ï¼‰
  const url = urlInput.value.trim();
  const hasLocal = !!fileInput.files[0] || !!imgInput.files[0];
  if (url && !hasLocal){
    if (!localStorage.getItem('ec_ack_public_url_key')){
      const ok = confirm('URLã ã‘ã‚’éµã«ã™ã‚‹ã¨ã€åŒã˜URLã«ã‚¢ã‚¯ã‚»ã‚¹ã§ãã‚‹äººã¯å¾©å·ã§ãã¾ã™ã€‚\nãã‚Œã§ã‚‚ç¶šè¡Œã—ã¾ã™ã‹ï¼Ÿ');
      if (!ok) throw new Error('ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã—ã¾ã—ãŸ');
      localStorage.setItem('ec_ack_public_url_key', '1');
    }
  }

  const joined = concatBytes(...parts);
  const baseKey = await sha256Bytes(joined);
  const extra = enc.encode('EC2:' + (htmlHash?'H':'') + (imgHash?'I':''));
  return { baseKey, extra };
}

// ===== AES-GCM =====
async function deriveAesKey(baseKey, saltBytes, extraBytes){
  const total = concatBytes(baseKey, saltBytes, extraBytes);
  const keyBytes = await sha256Bytes(total);
  return await crypto.subtle.importKey('raw', keyBytes, {name:'AES-GCM'}, false, ['encrypt','decrypt']);
}

async function encryptAesGcm(plainBytes, key, iv) {
  return new Uint8Array(await crypto.subtle.encrypt({ name: "AES-GCM", iv }, key, plainBytes));
}
async function decryptAesGcm(cipherBytes, key, iv) {
  return new Uint8Array(await crypto.subtle.decrypt({ name: "AES-GCM", iv }, key, cipherBytes));
}

function randomBytes(n){
  const u = new Uint8Array(n);
  crypto.getRandomValues(u);
  return u;
}

// ===== UI =====
function updateChips(){
  // URL ã¨ HTMLãƒ•ã‚¡ã‚¤ãƒ«ã¯ã€Œã©ã¡ã‚‰ã‹ä¸€æ–¹ã€ã«å›ºå®šï¼ˆæ··ã–ã‚‹ã¨å¾©å·å¤±æ•—ã®åŸå› ã«ãªã‚‹ï¼‰
  const hasHtmlFile = !!fileInput.files[0];

  if (hasHtmlFile){
    urlInput.value = '';
    urlInput.disabled = true;
  }else{
    urlInput.disabled = false;
  }

  // URLå…¥åŠ›ãŒã‚ã‚‹å ´åˆã¯ HTMLãƒ•ã‚¡ã‚¤ãƒ«é¸æŠã‚’è§£é™¤
  const url = urlInput.value.trim();
  if (url && fileInput.files.length){
    fileInput.value = '';
  }

  const hasHtml = !!fileInput.files[0] || !!urlInput.value.trim();
  const hasImg  = !!imgInput.files[0];

  chipHtml.textContent = hasHtml ? 'HTML: é¸æŠã‚ã‚Š' : 'HTML: æœªé¸æŠ';
  chipImg.textContent  = hasImg  ? 'ç”»åƒ: é¸æŠã‚ã‚Š' : 'ç”»åƒ: æœªé¸æŠ';
  chipHtml.className = 'chip' + (hasHtml ? ' on' : '');
  chipImg.className  = 'chip' + (hasImg  ? ' on' : '');

  const urlUsed = !!urlInput.value.trim() && !fileInput.files[0];
  const hasLocal = !!fileInput.files[0] || !!imgInput.files[0];
  urlWarn.style.display = (urlUsed && !hasLocal) ? 'block' : 'none';

  const hasKey = hasHtml || hasImg;
  const hasMsg = !!msgInput.value.trim();
  const hasCipher = !!cipherInput.value.trim();

  encryptBtn.disabled = !(hasKey && hasMsg);
  decryptBtn.disabled = !(hasKey && hasCipher);
}


[urlInput, fileInput, imgInput, msgInput].forEach(el=>{
  el.addEventListener('input', updateChips);
  el.addEventListener('change', updateChips);
});
updateChips();

encryptBtn.addEventListener('click', async ()=>{
  try{
    setStatus('æš—å·åŒ–ä¸­â€¦');
    const text = msgInput.value;
    if (!text.trim()) throw new Error('ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒç©ºã§ã™');
    const { baseKey, extra } = await buildBaseKey();
    const salt = randomBytes(16);
    const iv   = randomBytes(12);
    const key  = await deriveAesKey(baseKey, salt, extra);
    const ct   = await encryptAesGcm(enc.encode(text), key, iv);
    const packed = concatBytes(salt, iv, ct);
    outText.value = b64encode(packed);
    setStatus('æš—å·åŒ–ã—ã¾ã—ãŸ');
  }catch(e){
    setStatus(e.message || String(e), true);
  }
});

decryptBtn.addEventListener('click', async ()=>{
  try{
    setStatus('å¾©å·ä¸­â€¦');
    const b64 = msgInput.value.trim();
    if (!b64) throw new Error('ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒç©ºã§ã™');
    const packed = b64decode(b64);
    if (packed.length < 16+12+1) throw new Error('å½¢å¼ãŒä¸æ­£ã§ã™ï¼ˆçŸ­ã™ãã¾ã™ï¼‰');
    const salt = packed.subarray(0,16);
    const iv   = packed.subarray(16,28);
    const ct   = packed.subarray(28);
    const { baseKey, extra } = await buildBaseKey();
    const key  = await deriveAesKey(baseKey, salt, extra);
    const pt   = await decryptAesGcm(ct, key, iv);
    outText.value = dec.decode(pt);
    setStatus('å¾©å·ã—ã¾ã—ãŸ');
  }catch(e){
    setStatus('å¾©å·ã§ãã¾ã›ã‚“ã§ã—ãŸ: ' + (e.message || String(e)), true);
  }
});

copyBtn.addEventListener('click', async ()=>{
  const v = outText.value || '';
  if (!v) return;
  try{
    await navigator.clipboard.writeText(v);
    setStatus('ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸ');
  }catch{
    outText.select();
    document.execCommand('copy');
    setStatus('ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸ');
  }
});

clearBtn.addEventListener('click', ()=>{
  urlInput.value = '';
  fileInput.value = '';
  imgInput.value = '';
  msgInput.value = '';
  outText.value = '';
  setStatus('ã‚¯ãƒªã‚¢ã—ã¾ã—ãŸ');
  updateChips();
});

// ===== PWA =====
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('./sw.js?v=8', { scope: './' })
    .then(() => console.log('SW registered'))
    .catch(console.error);
}
</script>
</body>
</html>
