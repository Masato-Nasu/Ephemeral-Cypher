<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
<title>EphemeralCypher</title>

<link rel="manifest" href="./manifest.json">
<meta name="theme-color" content="#0b0c10">
<link rel="icon" href="./icon-192.png" type="image/png">
<link rel="apple-touch-icon" href="./icon-192.png">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

<style>
  :root{
    --bg: #0b0c10;
    --card: rgba(255,255,255,.06);
    --card2: rgba(255,255,255,.08);
    --text: rgba(255,255,255,.92);
    --muted: rgba(255,255,255,.62);
    --line: rgba(255,255,255,.12);
    --accent: #e7d2b3;
    --accent2: #f4e9d7;
    --danger: #ff6b6b;
    --shadow: 0 14px 40px rgba(0,0,0,.45);
    --radius: 18px;
  }
  *{ box-sizing:border-box; }
  html,body{ height:100%; }
  body{
    margin:0;
    font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    color: var(--text);
    background:
      radial-gradient(1200px 800px at 20% 0%, rgba(231,210,179,.20), transparent 60%),
      radial-gradient(900px 700px at 90% 20%, rgba(255,255,255,.10), transparent 55%),
      var(--bg);
    padding: 22px 14px 38px;
  }

  .app{ max-width: 720px; margin: 0 auto; }

  .top{
    display:flex; align-items:center; justify-content:space-between; gap:14px;
    margin-bottom: 14px;
  }
  .brand{ display:flex; align-items:center; gap:12px; }
  .logo{
    width:44px; height:44px; border-radius: 12px;
    box-shadow: 0 10px 26px rgba(0,0,0,.35);
    image-rendering: pixelated;
  }
  h1{ font-size: 18px; margin:0; letter-spacing:.2px; }
  .tag{ margin:2px 0 0; font-size: 12px; color: var(--muted); }

  .card{
    background: linear-gradient(180deg, var(--card2), var(--card));
    border: 1px solid var(--line);
    border-radius: var(--radius);
    box-shadow: var(--shadow);
    padding: 16px;
    backdrop-filter: blur(10px);
  }

  .tabs{
    display:flex; gap:10px;
    background: rgba(0,0,0,.18);
    border: 1px solid var(--line);
    border-radius: 999px;
    padding: 6px;
    margin-bottom: 12px;
  }
  .tab{
    flex:1;
    border:0;
    border-radius: 999px;
    padding: 10px 12px;
    background: transparent;
    color: var(--muted);
    cursor:pointer;
    font-weight: 600;
    letter-spacing:.1px;
  }
  .tab.active{
    background: rgba(231,210,179,.16);
    color: var(--text);
    box-shadow: inset 0 0 0 1px rgba(231,210,179,.22);
  }

  .status{
    margin: 10px 2px 14px;
    font-size: 13px;
    color: var(--muted);
    min-height: 18px;
  }

  .field{ margin: 12px 0; }
  .field label{
    display:block;
    font-size: 12px;
    color: var(--muted);
    margin: 0 0 6px 2px;
  }
  input[type="url"], input[type="password"], textarea{
    width:100%;
    border-radius: 14px;
    border: 1px solid var(--line);
    background: rgba(0,0,0,.26);
    color: var(--text);
    padding: 12px 12px;
    outline: none;
  }
  textarea{ min-height: 120px; resize: vertical; }

  input::placeholder, textarea::placeholder{ color: rgba(255,255,255,.35); }

  .actions{
    display:flex; flex-wrap:wrap; gap:10px;
    margin-top: 10px;
  }
  button.action{
    border: 1px solid var(--line);
    background: rgba(0,0,0,.18);
    color: var(--text);
    padding: 10px 12px;
    border-radius: 14px;
    cursor:pointer;
    font-weight: 600;
  }
  button.primary{
    border-color: rgba(231,210,179,.35);
    background: linear-gradient(180deg, rgba(231,210,179,.26), rgba(231,210,179,.10));
  }
  button.ghost{
    background: transparent;
  }
  button.action:active{ transform: translateY(1px); }

  details.advanced{
    margin-top: 14px;
    border-top: 1px solid var(--line);
    padding-top: 12px;
  }
  details.advanced > summary{
    cursor:pointer;
    list-style:none;
    color: var(--muted);
    font-size: 12px;
    user-select: none;
  }
  details.advanced > summary::-webkit-details-marker{ display:none; }

  .grid2{ display:grid; grid-template-columns: 1fr; gap: 10px; margin-top: 12px; }
  @media (min-width: 640px){
    .grid2{ grid-template-columns: 1fr 1fr; }
    textarea{ min-height: 140px; }
  }

  .inline{
    display:flex; align-items:center; gap:10px;
    padding: 10px 12px;
    border-radius: 14px;
    border: 1px solid var(--line);
    background: rgba(0,0,0,.18);
  }
  .inline label{ margin:0; color: var(--text); font-size: 12px; }
  .inline input{ width: 18px; height: 18px; accent-color: var(--accent); }

  .footer{
    margin-top: 14px;
    font-size: 11px;
    color: rgba(255,255,255,.40);
    text-align: center;
  }

  /* mode-specific button visibility (JSã‚‚ä½µç”¨) */
  body[data-mode="encrypt"] #decryptBtn{ display:none; }
  body[data-mode="decrypt"] #encryptBtn{ display:none; }
</style>
</head>
<body>
  <div class="app">
    <div class="top">
      <div class="brand">
        <img class="logo" src="./icon-192.png" alt="">
        <div>
          <h1>EphemeralCypher</h1>
          <p class="tag">ã‚·ãƒ³ãƒ—ãƒ«ãªãƒ†ã‚­ã‚¹ãƒˆæš—å·åŒ–</p>
        </div>
      </div>
      <button id="installBtn" class="action ghost" style="display:none">â¬‡ï¸ ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«</button>
    </div>

    <div class="card">
      <div class="tabs">
        <button id="tabEncrypt" class="tab active" type="button">æš—å·åŒ–</button>
        <button id="tabDecrypt" class="tab" type="button">å¾©å·</button>
      </div>

      <div class="status" id="status"></div>

      <div class="field">
        <label>åˆè¨€è‘‰</label>
        <input id="passphrase" type="password" placeholder="ä¾‹: 8æ–‡å­—ä»¥ä¸Šï¼ˆæ¨å¥¨ï¼‰">
      </div>

      <div class="field">
        <label id="msgLabel">ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸</label>
        <textarea id="messageInput" placeholder="ã“ã“ã«æš—å·åŒ–ã™ã‚‹ãƒ†ã‚­ã‚¹ãƒˆã‚’å…¥åŠ›"></textarea>
      </div>

      <div class="actions">
        <button id="encryptBtn" class="action primary" type="button">ğŸ” æš—å·åŒ–</button>
        <button id="decryptBtn" class="action primary" type="button">ğŸ”“ å¾©å·</button>
        <button id="copyBtn" class="action" type="button">ğŸ“‹ ã‚³ãƒ”ãƒ¼</button>
        <button id="clearBtn" class="action" type="button">ã‚¯ãƒªã‚¢</button>
        <button id="pasteBtn" class="action" type="button">è²¼ã‚Šä»˜ã‘â†’è‡ªå‹•åˆ¤å®š</button>
      </div>

      <div class="field">
        <label id="outLabel">çµæœï¼ˆBase64ï¼‰</label>
        <textarea id="outputText" readonly placeholder="ã“ã“ã«çµæœãŒè¡¨ç¤ºã•ã‚Œã¾ã™"></textarea>
      </div>

      <details class="advanced">
        <summary>ã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼ˆå¿…è¦ãªã¨ãã ã‘ï¼‰</summary>

        <div class="grid2">
          <div class="field">
            <label>URLï¼ˆéµç´ æã¨ã—ã¦HTMLã‚’ä½¿ã†å ´åˆï¼‰</label>
            <input id="urlInput" type="url" placeholder="https://example.com/page.html">
          </div>

          <div class="field">
            <label>HTMLãƒ•ã‚¡ã‚¤ãƒ«</label>
            <input id="fileInput" type="file" accept=".html,.htm,.txt">
          </div>

          <div class="field">
            <label>ç”»åƒãƒ•ã‚¡ã‚¤ãƒ«ï¼ˆé¸ã¶ã¨è‡ªå‹•ã§ç”»åƒéµã«ãªã‚Šã¾ã™ï¼‰</label>
            <input id="imgInput" type="file" accept="image/*">
          </div>

          <div class="inline">
            <input id="usePHash" type="checkbox">
            <label for="usePHash">ç”»åƒpHashã‚‚è©¦ã™ï¼ˆäº’æ›/å¯›å®¹ï¼‰</label>
          </div>

          <div class="inline">
            <input id="allowEmptyPass" type="checkbox">
            <label for="allowEmptyPass">åˆè¨€è‘‰ãªã—ã‚’è¨±å¯ï¼ˆä¸Šç´šè€…ï¼‰</label>
          </div>
        </div>

        <!-- äº’æ›ç”¨ï¼ˆéè¡¨ç¤ºï¼‰ -->
        <select id="encryptMode" style="display:none">
          <option value="strict-html-only" selected>strict</option>
          <option value="strict-img">strict-img</option>
          <option value="phash">phash</option>
        </select>
        <input id="tryStrictHtml" type="checkbox" checked style="display:none">
        <input id="tryStrictImg" type="checkbox" checked style="display:none">
        <input id="tryPHash" type="checkbox" checked style="display:none">
      </details>

      <div class="footer">â€» åˆè¨€è‘‰ã¯å¿˜ã‚Œã‚‹ã¨å¾©å·ã§ãã¾ã›ã‚“ã€‚å¿…è¦ãªã‚‰åˆ¥é€”ä¿ç®¡ã—ã¦ãã ã•ã„ã€‚</div>
    </div>
  </div>

<script>
// ====== å…±æœ‰ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ ======
const enc = new TextEncoder(), dec = new TextDecoder();
const statusEl = document.getElementById('status');
const urlInput = document.getElementById('urlInput');
const fileInput = document.getElementById('fileInput');
const imgInput  = document.getElementById('imgInput');
const passInput = document.getElementById('passphrase');
const encryptModeSel = document.getElementById('encryptMode');
const tryStrictHtmlCb = document.getElementById('tryStrictHtml');
const tryStrictImgCb  = document.getElementById('tryStrictImg');
const tryPHashCb      = document.getElementById('tryPHash');
const usePHashCb = document.getElementById('usePHash');
const allowEmptyPassCb = document.getElementById('allowEmptyPass');
const msgInput = document.getElementById('messageInput');
const outText  = document.getElementById('outputText');

function setStatus(txt, warn=false){ statusEl.textContent = txt; statusEl.style.color = warn ? '#a00' : '#111'; }
function toB64(bytes){ return btoa(String.fromCharCode(...bytes)); }
function fromB64(str){ return new Uint8Array(atob(str).split('').map(c=>c.charCodeAt(0))); }
async function sha256Bytes(bytes){ return new Uint8Array(await crypto.subtle.digest('SHA-256', bytes)); }

function normalizeHtmlText(text){
  if (!text) return "";
  if (text.charCodeAt(0) === 0xFEFF) text = text.slice(1);
  text = text.replace(/^\s*<!doctype[^>]*>/i, '');
  text = text.replace(/^\s*<\\?xml[^>]*\\?>/i, '');
  return text.trim();
}

async function fetchTextViaProxy(url){
  const proxy = 'https://api.allorigins.win/raw?url=' + encodeURIComponent(url);
  const res = await fetch(proxy, { cache:'no-store' });
  if (!res.ok) throw new Error('ãƒšãƒ¼ã‚¸å–å¾—å¤±æ•—: ' + res.status);
  return await res.text();
}

function readFileText(file){
  return new Promise((resolve,reject)=>{
    const r = new FileReader();
    r.onload = e => resolve(String(e.target.result||""));
    r.onerror = ()=> reject(new Error('ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼'));
    r.readAsText(file);
  });
}

// ====== HTMLãƒãƒƒã‚·ãƒ¥å–å¾—ï¼ˆç”»åƒã®ã¿éµã‚‚è¨±å®¹ï¼‰ ======
async function getBaseHashHTML(allowEmpty=false){
  const file = fileInput.files[0];
  const url  = urlInput.value.trim();
  if (file){
    const t = await readFileText(file);
    return await sha256Bytes(enc.encode(normalizeHtmlText(t)));
  } else if (url){
    const raw = await fetchTextViaProxy(url);
    return await sha256Bytes(enc.encode(normalizeHtmlText(raw)));
  }
  if (allowEmpty) return new Uint8Array(0);
  throw new Error('URL/HTMLãƒ•ã‚¡ã‚¤ãƒ«ãŒæœªæŒ‡å®šã§ã™ã€‚HTMLã‚’ä½¿ã‚ãªã„å ´åˆã¯ç”»åƒã®ã¿ãƒ¢ãƒ¼ãƒ‰ã«ã—ã¦ãã ã•ã„ã€‚');
}

// ====== ç”»åƒãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ ======
async function getLocalImageBlob(){
  const imgFile = imgInput.files && imgInput.files[0];
  if (!imgFile) return null;
  return imgFile;
}

async function getFirstImageURLFromHtml(rawHtml, baseUrl){
  try{
    const doc = new DOMParser().parseFromString(rawHtml, 'text/html');
    const img = doc.querySelector('img');
    if (!img || !img.src) return null;
    const a = document.createElement('a');
    a.href = img.src;
    if (!a.host && baseUrl){
      const u = new URL(baseUrl);
      return new URL(img.src, u).toString();
    }
    return img.src;
  }catch(e){ return null; }
}

async function fetchImageBlobViaProxy(imgUrl){
  const res = await fetch('https://api.allorigins.win/raw?url=' + encodeURIComponent(imgUrl), { cache:'no-store' });
  if (!res.ok) throw new Error('ç”»åƒå–å¾—å¤±æ•—: ' + res.status);
  return await res.blob();
}

async function imageBitmapFromBlob(blob){
  if ('createImageBitmap' in window){
    try { return await createImageBitmap(blob); } catch(e){}
  }
  return await new Promise((resolve,reject)=>{
    const url = URL.createObjectURL(blob);
    const img = new Image();
    img.onload = ()=>{ resolve(img); URL.revokeObjectURL(url); };
    img.onerror = ()=>{ reject(new Error('ç”»åƒãƒ‡ã‚³ãƒ¼ãƒ‰å¤±æ•—')); URL.revokeObjectURL(url); };
    img.src = url;
  });
}

function getCanvasCtx(w,h){
  const c = document.createElement('canvas');
  c.width = w; c.height = h;
  const ctx = c.getContext('2d', { willReadFrequently:true });
  return { canvas: c, ctx };
}

function dct2dFloat(Y, N){
  const C = new Float32Array(N*N);
  const pi = Math.PI, invN = 1/Math.sqrt(N);
  const alpha = (k)=> k===0 ? invN : Math.sqrt(2/N);
  const tmp = new Float32Array(N*N);
  for (let y=0;y<N;y++){
    for (let u=0;u<N;u++){
      let sum=0;
      for (let x=0;x<N;x++){
        sum += Y[y*N+x]*Math.cos(((2*x+1)*u*pi)/(2*N));
      }
      tmp[y*N+u] = alpha(u)*sum;
    }
  }
  for (let u=0;u<N;u++){
    for (let v=0;v<N;v++){
      let sum=0;
      for (let y=0;y<N;y++){
        sum += tmp[y*N+u]*Math.cos(((2*y+1)*v*pi)/(2*N));
      }
      C[v*N+u] = alpha(v)*sum;
    }
  }
  return C;
}

async function computeImagePHashBytesFromBlob(blob){
  const bmp = await imageBitmapFromBlob(blob);
  const size = 32;
  const {canvas,ctx} = getCanvasCtx(size, size);
  ctx.drawImage(bmp, 0, 0, size, size);
  const imgData = ctx.getImageData(0,0,size,size).data;
  const Y = new Float32Array(size*size);
  for (let i=0, j=0; i<imgData.length; i+=4, j++){
    const r=imgData[i], g=imgData[i+1], b=imgData[i+2];
    Y[j] = 0.299*r + 0.587*g + 0.114*b;
  }
  const D = dct2dFloat(Y, size);
  const block = [];
  for (let v=0; v<8; v++){
    for (let u=0; u<8; u++){
      block.push(D[v*size + u]);
    }
  }
  const mean = block.slice(1).reduce((a,b)=>a+b,0)/(block.length-1);
  let bits = 0n;
  for (let k=0;k<64;k++){
    bits = (bits<<1n) | (block[k] > mean ? 1n : 0n);
  }
  const phash = new Uint8Array(8);
  for (let i=7;i>=0;i--){ phash[i] = Number(bits & 0xFFn); bits >>= 8n; }
  return phash;
}

// ====== éµå°å‡º & AES-GCM ======
async function deriveAesKey(baseHashHTML, passphrase, saltBytes, extraBytes){
  const passB = new TextEncoder().encode(passphrase || "");
  const total = new Uint8Array(baseHashHTML.length + passB.length + saltBytes.length + (extraBytes?extraBytes.length:0));
  let off=0;
  total.set(baseHashHTML, off); off += baseHashHTML.length;
  total.set(passB, off);        off += passB.length;
  total.set(saltBytes, off);    off += saltBytes.length;
  if (extraBytes){ total.set(extraBytes, off); }
  const keyBytes = await crypto.subtle.digest('SHA-256', total).then(buf=>new Uint8Array(buf));
  return await crypto.subtle.importKey('raw', keyBytes, {name:'AES-GCM'}, false, ['encrypt','decrypt']);
}

async function encryptAesGcm(plainBytes, key, iv) {
  return new Uint8Array(await crypto.subtle.encrypt(
    { name: "AES-GCM", iv: iv },
    key,
    plainBytes
  ));
}

async function decryptAesGcm(cipherBytes, key, iv) {
  return new Uint8Array(await crypto.subtle.decrypt(
    { name: "AES-GCM", iv: iv },
    key,
    cipherBytes
  ));
}

// ====== ç”»åƒã‚­ãƒ¼ç´ æã®ç”Ÿæˆ ======
async function buildStrictImageBytes(url){
  const local = await getLocalImageBlob();
  if (local) {
    const ab = await local.arrayBuffer();
    return new Uint8Array(ab);
  }
  if (!url) return null;
  const raw = await fetchTextViaProxy(url);
  const imgUrl = await getFirstImageURLFromHtml(raw, url);
  if (!imgUrl) return null;
  const blob = await fetchImageBlobViaProxy(imgUrl);
  const ab = await blob.arrayBuffer();
  return new Uint8Array(ab);
}

async function buildPHashBytes(url){
  const local = await getLocalImageBlob();
  if (local) {
    return await computeImagePHashBytesFromBlob(local);
  }
  if (!url) return null;
  const raw = await fetchTextViaProxy(url);
  const imgUrl = await getFirstImageURLFromHtml(raw, url);
  if (!imgUrl) return null;
  const blob = await fetchImageBlobViaProxy(imgUrl);
  return await computeImagePHashBytesFromBlob(blob);
}

// ====== æš—å·åŒ– ======
async function encryptFlow(){
  try{
    setStatus('æº–å‚™ä¸­...');
    const url = (urlInput.value||'').trim();
    const pass = passInput.value || '';
    const allowEmpty = !!(allowEmptyPassCb && allowEmptyPassCb.checked);
    const phashOn = !!(usePHashCb && usePHashCb.checked);
    const hasLocalImg = !!(imgInput.files && imgInput.files[0]);

    if (!pass && !allowEmpty){
      throw new Error('åˆè¨€è‘‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ï¼ˆä¸Šç´šè€…: ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã§ã€Œåˆè¨€è‘‰ãªã—ã€ã‚’è¨±å¯ã§ãã¾ã™ï¼‰');
    }

    // UIã‚’ã‚·ãƒ³ãƒ—ãƒ«ã«ã™ã‚‹ãŸã‚ã€æš—å·åŒ–ãƒ¢ãƒ¼ãƒ‰ã¯è‡ªå‹•æ±ºå®šã—ã¾ã™ï¼š
    // ç”»åƒãƒ•ã‚¡ã‚¤ãƒ«ãŒé¸ã°ã‚Œã¦ã„ã‚Œã°ç”»åƒéµï¼ˆå³æ ¼/å¯›å®¹ï¼‰ã€ãªã‘ã‚Œã°HTMLéµï¼ˆURL/HTMLãƒ•ã‚¡ã‚¤ãƒ«ï¼‰ã‚’ä½¿ç”¨
    let mode = 'strict-html-only';
    if (hasLocalImg){
      mode = phashOn ? 'phash' : 'strict-img';
    }
    if (encryptModeSel) encryptModeSel.value = mode;

    setStatus('éµç´ æå–å¾—ä¸­...');
    const baseHash = await getBaseHashHTML(true);

    let extra = null;
    if (mode === 'strict-img'){
      extra = await buildStrictImageBytes(url);
      if (!extra) throw new Error('ç”»åƒãŒæŒ‡å®šã•ã‚Œã¦ã„ã¾ã›ã‚“ï¼ˆç”»åƒãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„ï¼‰');
    } else if (mode === 'phash'){
      extra = await buildPHashBytes(url);
      if (!extra) throw new Error('ç”»åƒãŒæŒ‡å®šã•ã‚Œã¦ã„ã¾ã›ã‚“ï¼ˆç”»åƒãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„ï¼‰');
    }

    // ğŸ”’ ç©ºéµç¦æ­¢ï¼špassphrase / HTML / ç”»åƒ ã®ã©ã‚Œã‹ã¯å¿…é ˆï¼ˆå®‰å…¨ä¸Šï¼‰
    const hasPass = !!pass.trim();
    const hasHtml = !!(fileInput.files[0] || url);
    const hasImg  = !!(imgInput.files[0]);
    if (!hasPass && !hasHtml && !hasImg){
      throw new Error('éµç´ æãŒç©ºã§ã™ï¼šåˆè¨€è‘‰ã€ã¾ãŸã¯ URL/HTML/ç”»åƒ ã®ã„ãšã‚Œã‹ã‚’æŒ‡å®šã—ã¦ãã ã•ã„');
    }

    const salt = crypto.getRandomValues(new Uint8Array(12));
    const iv   = crypto.getRandomValues(new Uint8Array(12));
    const key  = await deriveAesKey(baseHash, pass, salt, extra);

    const pt = new TextEncoder().encode(msgInput.value||"");
    if (!pt.length) throw new Error('æš—å·åŒ–ã™ã‚‹ãƒ†ã‚­ã‚¹ãƒˆã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');

    setStatus('æš—å·åŒ–ä¸­...');
    const ct = await encryptAesGcm(pt, key, iv);
    const out = new Uint8Array(salt.length + iv.length + ct.length);
    out.set(salt,0); out.set(iv,12); out.set(ct,24);
    outText.value = btoa(String.fromCharCode(...out));
    setStatus('âœ… æš—å·åŒ–ã—ã¾ã—ãŸ');
  }catch(e){
    outText.value = '';
    setStatus('ğŸ”´ æš—å·åŒ–å¤±æ•—: ' + (e.message||e), true);
  }
}

// ====== å¾©å· ======
async function decryptFlow(){
  try{
    const input = (msgInput.value||"").trim();
    if (!input) throw new Error('å¾©å·ã™ã‚‹ base64 ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');
    const data = new Uint8Array(atob(input.replace(/\s+/g,'')).split('').map(c=>c.charCodeAt(0)));
    if (data.length < 24) throw new Error('å…¥åŠ›ãŒçŸ­ã™ãã¾ã™');
    const salt = data.slice(0,12);
    const iv   = data.slice(12,24);
    const ct   = data.slice(24);

    const url = (urlInput.value||'').trim();
    const pass = passInput.value || '';
    const allowEmpty = !!(allowEmptyPassCb && allowEmptyPassCb.checked);
    const phashOn = !!(usePHashCb && usePHashCb.checked);
    const hasLocalImg = !!(imgInput.files && imgInput.files[0]);
    const hasHtml = !!(fileInput.files[0] || url);
    const hasImg  = !!(imgInput.files[0]);

    if (!pass && !allowEmpty){
      throw new Error('åˆè¨€è‘‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ï¼ˆä¸Šç´šè€…: ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã§ã€Œåˆè¨€è‘‰ãªã—ã€ã‚’è¨±å¯ã§ãã¾ã™ï¼‰');
    }

    setStatus('éµç´ æå–å¾—ä¸­...');
    const baseHash = await getBaseHashHTML(true);

    // âš ï¸ éµç´ æãŒå®Œå…¨ã«ç©ºã®ã¾ã¾å¾©å·ã™ã‚‹ã¨å±é™ºãªçŠ¶æ…‹ã«ãªã‚Šå¾—ã¾ã™ï¼ˆéå»ãƒ‡ãƒ¼ã‚¿æ•‘å‡ºç”¨é€”ã®ã¿ï¼‰
    if (!pass && !hasHtml && !hasImg){
      const ok = confirm('âš ï¸ åˆè¨€è‘‰/URL/HTML/ç”»åƒãŒæœªæŒ‡å®šã§ã™ã€‚\néå»ã«ä½œæˆã—ãŸã€Œç©ºéµæš—å·æ–‡ã€ã®æ•‘å‡ºä»¥å¤–ã§ã¯å±é™ºã§ã™ã€‚\nç¶šè¡Œã—ã¾ã™ã‹ï¼Ÿ');
      if (!ok) throw new Error('ä¸­æ­¢ã—ã¾ã—ãŸ');
    }

    const tryList = [];
    // ã¾ãšã¯HTMLã®ã¿ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆï¼‰
    tryList.push({ name:'HTMLã®ã¿', buildExtra: async()=>null });

    // ç”»åƒãƒ•ã‚¡ã‚¤ãƒ«ãŒé¸æŠã•ã‚Œã¦ã„ã‚Œã°ã€ç”»åƒéµã‚‚è©¦ã™
    if (hasLocalImg){
      tryList.push({ name:'ç”»åƒ(å³æ ¼)', buildExtra: async()=> await buildStrictImageBytes(url) });
      if (phashOn){
        tryList.push({ name:'ç”»åƒ(pHash)', buildExtra: async()=> await buildPHashBytes(url) });
      }
    }

    let lastErr = null;
    for (const cand of tryList){
      try{
        setStatus('å¾©å·ä¸­: ' + cand.name + ' ...');
        const extra = await cand.buildExtra();
        const key   = await deriveAesKey(baseHash, pass, salt, extra||null);
        const pt    = await decryptAesGcm(ct, key, iv);
        outText.value = new TextDecoder().decode(pt);
        setStatus('âœ… å¾©å·ã—ã¾ã—ãŸï¼ˆ' + cand.name + 'ï¼‰');
        return;
      }catch(err){
        lastErr = err;
      }
    }
    throw lastErr || new Error('å¾©å·ã«å¤±æ•—ã—ã¾ã—ãŸ');
  }catch(e){
    outText.value = '';
    setStatus('ğŸ”´ å¾©å·å¤±æ•—: ' + (e.message||e), true);
  }
}

// ====== UI ãƒã‚¤ãƒ³ãƒ‰ ======
// ====== ç”»é¢ãƒ¢ãƒ¼ãƒ‰ï¼ˆæš—å·åŒ– / å¾©å·ï¼‰ ======
const tabEncryptBtn = document.getElementById('tabEncrypt');
const tabDecryptBtn = document.getElementById('tabDecrypt');
const msgLabelEl = document.getElementById('msgLabel');
const outLabelEl = document.getElementById('outLabel');

function setMode(mode){
  document.body.dataset.mode = mode;
  const isDec = (mode === 'decrypt');
  if (msgLabelEl) msgLabelEl.textContent = isDec ? 'æš—å·æ–‡ï¼ˆBase64ï¼‰' : 'ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸';
  if (outLabelEl) outLabelEl.textContent = isDec ? 'å¾©å·çµæœ' : 'çµæœï¼ˆBase64ï¼‰';
  msgInput.placeholder = isDec ? 'ã“ã“ã«æš—å·æ–‡ï¼ˆBase64ï¼‰ã‚’è²¼ã‚Šä»˜ã‘' : 'ã“ã“ã«æš—å·åŒ–ã™ã‚‹ãƒ†ã‚­ã‚¹ãƒˆã‚’å…¥åŠ›';
  outText.placeholder  = isDec ? 'å¾©å·ã•ã‚ŒãŸãƒ†ã‚­ã‚¹ãƒˆãŒè¡¨ç¤ºã•ã‚Œã¾ã™' : 'æš—å·æ–‡ï¼ˆBase64ï¼‰ãŒè¡¨ç¤ºã•ã‚Œã¾ã™';
  const encBtn = document.getElementById('encryptBtn');
  const decBtn = document.getElementById('decryptBtn');
  if (encBtn) encBtn.style.display = isDec ? 'none' : 'inline-flex';
  if (decBtn) decBtn.style.display = isDec ? 'inline-flex' : 'none';
}

if (tabEncryptBtn && tabDecryptBtn){
  tabEncryptBtn.addEventListener('click', ()=>{
    tabEncryptBtn.classList.add('active');
    tabDecryptBtn.classList.remove('active');
    setMode('encrypt');
  });
  tabDecryptBtn.addEventListener('click', ()=>{
    tabDecryptBtn.classList.add('active');
    tabEncryptBtn.classList.remove('active');
    setMode('decrypt');
  });
}
setMode('encrypt');

document.getElementById('encryptBtn').addEventListener('click', encryptFlow);
document.getElementById('decryptBtn').addEventListener('click', decryptFlow);
document.getElementById('pasteBtn').addEventListener('click', async ()=>{
  try{
    const txt = await navigator.clipboard.readText();
    if (!txt){ setStatus('ğŸ“‹ ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«æ–‡å­—ãŒã‚ã‚Šã¾ã›ã‚“', true); return; }
    msgInput.value = txt;
    const v = txt.trim();
    if (/^[A-Za-z0-9+/=\\s]+$/.test(v) && v.replace(/\\s+/g,'').length>24){
      setStatus('Base64æ¤œå‡ºâ†’å¾©å·ï¼ˆè‡ªå‹•è©¦è¡Œï¼‰ã‚’å®Ÿè¡Œ'); await decryptFlow();
    }else{
      setStatus('ãƒ†ã‚­ã‚¹ãƒˆæ¤œå‡ºâ†’æš—å·åŒ–ã‚’å®Ÿè¡Œ'); await encryptFlow();
    }
  }catch(e){ setStatus('âŒ ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰èª­ã¿å–ã‚Šå¤±æ•—: ' + (e.message||e), true); }
});
document.getElementById('copyBtn').addEventListener('click', ()=>{
  outText.select(); document.execCommand('copy'); setStatus('ğŸ“‹ å‡ºåŠ›ã‚’ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸ');
});
document.getElementById('clearBtn').addEventListener('click', ()=>{
  // ã™ã¹ã¦ã®å…¥åŠ›ã‚’ã‚¯ãƒªã‚¢ï¼ˆç”»åƒãƒ»HTMLãƒ»URLãƒ»ãƒ‘ã‚¹ãƒ•ãƒ¬ãƒ¼ã‚ºãƒ»ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ï¼‰
  msgInput.value='';
  outText.value='';
  urlInput.value='';
  if (fileInput.value) fileInput.value='';
  if (imgInput.value)  imgInput.value='';    // â† ç”»åƒã‚‚ã‚¯ãƒªã‚¢
  passInput.value='';
  setStatus('å…¥åŠ›ã‚’ã™ã¹ã¦ã‚¯ãƒªã‚¢ã—ã¾ã—ãŸ');
});

setStatus('æº–å‚™å®Œäº†');
</script>
<script>
let deferredPrompt = null;
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('./sw.js?v=6', { scope: './' })
    .then(() => console.log('SW registered'))
    .catch(console.error);
}
window.addEventListener('beforeinstallprompt', (e) => {
  e.preventDefault();
  deferredPrompt = e;
  document.getElementById('installBtn').style.display = 'inline-block';
});
document.getElementById('installBtn').addEventListener('click', async () => {
  if (!deferredPrompt) return;
  deferredPrompt.prompt();
  const { outcome } = await deferredPrompt.userChoice;
  console.log('PWA install:', outcome);
  deferredPrompt = null;
  document.getElementById('installBtn').style.display = 'none';
});
</script>
</body>
</html>
