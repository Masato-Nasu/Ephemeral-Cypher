<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>EphemeralCypher</title>
<link rel="manifest" href="./manifest.json">
<link rel="icon" href="./icon-192.png" type="image/png">
<meta name="theme-color" content="#0b0b0f">
<style>
  :root{
    --bg:#0b0b0f;
    --card:#12121a;
    --card2:#151523;
    --text:#f2f2f7;
    --muted:rgba(242,242,247,.62);
    --line:rgba(255,255,255,.09);
    --accent:#b9a7ff;
    --danger:#ff6b6b;
  }
  *{box-sizing:border-box}
  body{
    margin:0;
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    background: radial-gradient(1200px 600px at 20% -10%, rgba(185,167,255,.18), transparent 55%),
                radial-gradient(900px 500px at 100% 0%, rgba(255,255,255,.08), transparent 55%),
                var(--bg);
    color:var(--text);
  }
  .wrap{max-width:860px;margin:0 auto;padding:28px 18px 42px}
  .hero{
    display:flex;align-items:center;gap:12px;margin-bottom:18px
  }
  .logo{
    width:40px;height:40px;border-radius:14px;
    background: linear-gradient(145deg, rgba(185,167,255,.26), rgba(255,255,255,.06));
    border:1px solid var(--line);
    display:grid;place-items:center;
    box-shadow: 0 12px 32px rgba(0,0,0,.35);
  }
  .title{font-size:18px;font-weight:700;letter-spacing:.2px;margin:0}
  .sub{margin:2px 0 0 0;color:var(--muted);font-size:13px}
  .card{
    background: linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.01));
    border:1px solid var(--line);
    border-radius:18px;
    padding:16px;
    box-shadow: 0 16px 50px rgba(0,0,0,.35);
  }
  .grid{display:grid;gap:14px}
  @media (min-width: 860px){ .grid.cols2{grid-template-columns: 1fr 1fr;} }
  label{display:block;font-size:12px;color:var(--muted);margin:0 0 8px 2px}
  input[type="text"], textarea, input[type="file"]{
    width:100%;
    background: rgba(255,255,255,.03);
    border:1px solid var(--line);
    color:var(--text);
    border-radius:14px;
    padding:12px 12px;
    outline:none;
  }
  input[type="file"]{padding:10px}
  textarea{min-height:132px;resize:vertical;line-height:1.5}
  .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  .btn{
    border-radius:14px;border:1px solid var(--line);
    padding:12px 14px;background: rgba(255,255,255,.04);
    color:var(--text);font-weight:700;cursor:pointer;
    transition: transform .06s ease, background .2s ease, border-color .2s ease;
    user-select:none;
  }
  .btn:hover{background: rgba(255,255,255,.06);border-color: rgba(255,255,255,.14)}
  .btn:active{transform: translateY(1px)}
  .btn.primary{
    background: linear-gradient(145deg, rgba(185,167,255,.34), rgba(255,255,255,.06));
    border-color: rgba(185,167,255,.32);
  }
  .btn.danger{border-color: rgba(255,107,107,.35); background: rgba(255,107,107,.08)}
  .btn:disabled{opacity:.45;cursor:not-allowed;transform:none}
  .chip{
    font-size:12px; padding:6px 10px;border-radius:999px;
    border:1px solid var(--line); color:var(--muted); background: rgba(255,255,255,.02);
  }
  .chip.on{color:rgba(242,242,247,.92); border-color: rgba(185,167,255,.35); background: rgba(185,167,255,.10)}
  .status{margin-top:10px;font-size:12px;color:var(--muted)}
  .status.err{color: var(--danger)}
  .hr{height:1px;background: var(--line); margin: 14px 0}
  .mini{font-size:12px;color:var(--muted);margin: 8px 2px 0}
  .right{margin-left:auto}

</style>
</head>
<body>
<div class="wrap">
  <div class="hero">
    <div class="logo"></div>
    <div>
      <p class="title">EphemeralCypher</p>
    </div>
  </div>

  <div class="card grid cols2">
    <div>
      <label data-i18n="key_url"></label>
      <input id="urlInput" type="url" inputmode="url" spellcheck="false" autocomplete="off">
    </div>

    <div>
      <label data-i18n="key_image"></label>
      <input id="imgInput" type="file" accept="image/*">
    </div>

    <div style="grid-column: 1 / -1;">
      <div class="hr"></div>
      <label data-i18n="message"></label>
      <textarea id="messageInput"></textarea>

      <div class="row" style="margin-top:10px">
        <button id="encryptBtn" class="btn primary" data-i18n="encrypt"></button>
        <button id="decryptBtn" class="btn" data-i18n="decrypt"></button>
      </div>

      <div id="status" class="status"></div>
    </div>
  </div>
</div>

<script>
/* ========= i18n ========= */
const I18N = {
  en: {
    key_url: "Key material: Web page URL",
    key_image: "Key material: Image",
    message: "Message (plain text or base64 ciphertext)",
    encrypt: "Encrypt",
    decrypt: "Decrypt",
    url_placeholder: "https://example.com",
    placeholder: "Type here…",
    ready: "Ready",
    hint_key: "Enter a URL and/or select an image.",
    hint_msg: "Enter a message.",
    encrypting: "Encrypting…",
    decrypting: "Decrypting…",
    done_encrypt: "Encrypted",
    done_decrypt: "Decrypted",
    err_no_key: "No key material selected.",
    err_empty_msg: "Message is empty.",
    err_bad_format: "Invalid format.",
    err_decrypt: "Decryption failed."
  },
  ja: {
    key_url: "鍵素材：ページURL",
    key_image: "鍵素材：画像ファイル",
    message: "メッセージ（平文 または 暗号文 base64）",
    encrypt: "暗号化",
    decrypt: "復号",
    url_placeholder: "https://example.com",
    placeholder: "ここに入力…",
    ready: "準備完了",
    hint_key: "URLを入力するか画像を選択してください。",
    hint_msg: "メッセージを入力してください。",
    encrypting: "暗号化中…",
    decrypting: "復号中…",
    done_encrypt: "暗号化しました",
    done_decrypt: "復号しました",
    err_no_key: "鍵素材がありません。",
    err_empty_msg: "メッセージが空です。",
    err_bad_format: "形式が不正です。",
    err_decrypt: "復号できませんでした。"
  }
};

function detectLang(){
  const qs = new URLSearchParams(location.search);
  const forced = (qs.get('lang')||"").toLowerCase();
  if (forced === "ja" || forced === "en") return forced;
  const nav = (navigator.language || "en").toLowerCase();
  return nav.startsWith("ja") ? "ja" : "en";
}
const LANG = detectLang();
function t(k){ return (I18N[LANG] && I18N[LANG][k]) || I18N.en[k] || k; }

document.documentElement.lang = LANG;
document.querySelectorAll('[data-i18n]').forEach(el => {
  el.textContent = t(el.dataset.i18n);
});

/* ========= DOM ========= */
const enc = new TextEncoder(), dec = new TextDecoder();
const urlInput  = document.getElementById('urlInput');
const imgInput  = document.getElementById('imgInput');
const msgInput  = document.getElementById('messageInput');
const encryptBtn = document.getElementById('encryptBtn');
const decryptBtn = document.getElementById('decryptBtn');
const statusEl   = document.getElementById('status');

msgInput.placeholder = t('placeholder');
urlInput.placeholder = t('url_placeholder');

function setStatus(text, isError=false){
  statusEl.textContent = text || "";
  statusEl.style.borderColor = isError ? 'rgba(255,107,107,.35)' : 'rgba(255,255,255,.12)';
  statusEl.style.background  = isError ? 'rgba(255,107,107,.08)' : 'rgba(255,255,255,.03)';
}

/* ========= Helpers ========= */
function concatBytes(...arrs){
  const len = arrs.reduce((s,b)=>s+(b?b.length:0),0);
  const out = new Uint8Array(len);
  let off=0;
  for (const a of arrs){
    if (!a) continue;
    out.set(a, off); off += a.length;
  }
  return out;
}

async function sha256Bytes(bytes){
  const buf = await crypto.subtle.digest('SHA-256', bytes);
  return new Uint8Array(buf);
}

function b64encode(u8){
  let s = '';
  const chunk = 0x8000;
  for (let i=0;i<u8.length;i+=chunk){
    s += String.fromCharCode(...u8.subarray(i,i+chunk));
  }
  return btoa(s);
}
function b64decode(s){
  const bin = atob(s.replace(/\s+/g,''));
  const out = new Uint8Array(bin.length);
  for (let i=0;i<bin.length;i++) out[i] = bin.charCodeAt(i);
  return out;
}

function normalizeHtmlText(html){
  const doc = new DOMParser().parseFromString(html, 'text/html');
  doc.querySelectorAll('script,style,noscript,template').forEach(n=>n.remove());
  const txt = (doc.body ? doc.body.textContent : doc.textContent) || '';
  return txt
    .replace(/\u00A0/g,' ')
    .replace(/[\s\r\n\t]+/g,' ')
    .trim();
}

function readFileText(f){
  return new Promise((res,rej)=>{
    const r = new FileReader();
    r.onload = ()=>res(String(r.result||""));
    r.onerror = ()=>rej(r.error||new Error('read error'));
    r.readAsText(f);
  });
}

/* ========= HTML key ========= */
function normalizeUrlInput(raw){
  let s = (raw || '').trim();
  if (!s) return '';
  if (!/^https?:\/\//i.test(s)) s = 'https://' + s;
  return s;
}
function isPrivateHost(host){
  if (!host) return true;
  host = host.toLowerCase();
  if (host === 'localhost' || host.endsWith('.local')) return true;
  if (/^(127\.|10\.|192\.168\.|172\.(1[6-9]|2\d|3[0-1])\.)/.test(host)) return true;
  return false;
}
async function fetchTextWithTimeout(url, ms=9000){
  const ctrl = new AbortController();
  const id = setTimeout(()=>ctrl.abort(), ms);
  try{
    const res = await fetch(url, {
      signal: ctrl.signal,
      cache: 'no-store',
      redirect: 'follow',
      mode: 'cors',
      credentials: 'omit',
    });
    if (!res.ok) throw new Error('HTTP ' + res.status);
    return await res.text();
  } finally {
    clearTimeout(id);
  }
}
async function fetchHtmlText(url){
  try {
    return await fetchTextWithTimeout(url, 9000);
  } catch (e) {
    try{
      const u = new URL(url);
      if (isPrivateHost(u.hostname)) throw e;
      return await fetchTextWithTimeout('https://r.jina.ai/' + url, 9000);
    } catch(_) {
      throw e;
    }
  }
}

async function getHtmlHash(){
  const url = normalizeUrlInput(urlInput.value);
  if (!url) return null;
  const t0 = await fetchHtmlText(url);
  return await sha256Bytes(enc.encode(normalizeHtmlText(t0)));
}


/* ========= Image hash ========= */
async function createBitmapSafe(blob){
  try {
    if ('createImageBitmap' in window) return await createImageBitmap(blob);
  } catch(_) {}
  return new Promise((resolve, reject)=>{
    const img = new Image();
    img.onload = ()=>resolve(img);
    img.onerror = ()=>reject(new Error('image decode error'));
    img.src = URL.createObjectURL(blob);
  });
}

async function drawImageToRGBA(blob, w, h){
  const bmp = await createBitmapSafe(blob);
  const c = document.createElement('canvas');
  c.width = w; c.height = h;
  const ctx = c.getContext('2d', { willReadFrequently:true });
  ctx.imageSmoothingEnabled = true;
  try{ ctx.imageSmoothingQuality = 'high'; }catch(_){}
  try{ ctx.filter = 'blur(0.6px)'; }catch(_){}
  ctx.drawImage(bmp, 0, 0, w, h);
  try{ ctx.filter = 'none'; }catch(_){}
  const img = ctx.getImageData(0,0,w,h).data;
  const out = new Uint8Array(w*h*4);
  out.set(img);
  try{ if (bmp.close) bmp.close(); }catch(_){}
  return out;
}

function rgbaToLuma(rgba){
  const n = rgba.length/4;
  const y = new Float32Array(n);
  for (let i=0;i<n;i++) {
    const r = rgba[i*4], g = rgba[i*4+1], b = rgba[i*4+2];
    y[i] = 0.2126*r + 0.7152*g + 0.0722*b;
  }
  return y;
}

function dHashFromLuma(y, w, h){
  const bits = [];
  for (let row=0; row<h; row++) {
    const off = row*w;
    for (let col=0; col<w-1; col++) {
      bits.push(y[off+col] > y[off+col+1] ? 1 : 0);
    }
  }
  const out = new Uint8Array(Math.ceil(bits.length/8));
  for (let i=0;i<bits.length;i++) {
    out[i>>3] |= (bits[i] & 1) << (7-(i&7));
  }
  return out;
}

// Minimal DCT for pHash
const _PH_N = 32;
const _PH_K = 8;
const _PH_ALPHA = new Float32Array(_PH_N);
(function initAlpha(){
  _PH_ALPHA[0] = Math.sqrt(1/_PH_N);
  for (let k=1;k<_PH_N;k++) _PH_ALPHA[k] = Math.sqrt(2/_PH_N);
})();

function dct2(block){
  const N=_PH_N;
  const out = new Float32Array(N*N);
  const cosX = Array.from({length:N}, (_,u)=>Array.from({length:N}, (_,x)=>Math.cos(((2*x+1)*u*Math.PI)/(2*N))));
  const cosY = Array.from({length:N}, (_,v)=>Array.from({length:N}, (_,y)=>Math.cos(((2*y+1)*v*Math.PI)/(2*N))));
  for (let u=0;u<N;u++) {
    for (let v=0;v<N;v++) {
      let sum=0;
      for (let x=0;x<N;x++) {
        const cx = cosX[u][x];
        const rowOff = x*N;
        for (let y=0;y<N;y++) {
          sum += block[rowOff+y] * cx * cosY[v][y];
        }
      }
      out[u*N+v] = _PH_ALPHA[u]*_PH_ALPHA[v]*sum;
    }
  }
  return out;
}

function pHashFromLuma(y){
  const N=_PH_N;
  const centered = new Float32Array(N*N);
  for (let i=0;i<centered.length;i++) centered[i] = y[i] - 128.0;
  const dct = dct2(centered);
  const vals = [];
  for (let u=0;u<_PH_K;u++) {
    for (let v=0;v<_PH_K;v++) {
      if (u===0 && v===0) continue;
      vals.push(dct[u*N+v]);
    }
  }
  const sorted = vals.slice().sort((a,b)=>a-b);
  const med = sorted[Math.floor(sorted.length/2)] || 0;
  const bits = [];
  for (let u=0;u<_PH_K;u++) {
    for (let v=0;v<_PH_K;v++) {
      if (u===0 && v===0) continue;
      bits.push(dct[u*N+v] > med ? 1 : 0);
    }
  }
  const out = new Uint8Array(Math.ceil(bits.length/8));
  for (let i=0;i<bits.length;i++) {
    out[i>>3] |= (bits[i]&1) << (7-(i&7));
  }
  return out;
}

async function imageHash_PD(blob){
  const rgba32 = await drawImageToRGBA(blob, 32, 32);
  const y32 = rgbaToLuma(rgba32);
  const ph = pHashFromLuma(y32);

  const rgbaDH = await drawImageToRGBA(blob, 9, 8);
  const yDH = rgbaToLuma(rgbaDH);
  const dh = dHashFromLuma(yDH, 9, 8);

  return await sha256Bytes(concatBytes(new Uint8Array([0x50,0x44]), ph, dh)); // "PD"
}
async function imageHash_DH_legacy(blob){
  const rgba = await drawImageToRGBA(blob, 9, 8);
  const y = rgbaToLuma(rgba);
  const dh = dHashFromLuma(y, 9, 8);
  return await sha256Bytes(concatBytes(new Uint8Array([0x44,0x48]), dh)); // "DH"
}
async function imageHash_RAW(blob){
  const bytes = new Uint8Array(await blob.arrayBuffer());
  return await sha256Bytes(concatBytes(new Uint8Array([0x52,0x41,0x57]), bytes)); // "RAW"
}

async function getImageHash(variant='PD'){
  const f = imgInput.files[0];
  if (!f) return null;
  const blob = f;
  if (variant === 'PD') return await imageHash_PD(blob);
  if (variant === 'DH') return await imageHash_DH_legacy(blob);
  if (variant === 'RAW') return await imageHash_RAW(blob);
  return await imageHash_PD(blob);
}

/* ========= Key derivation ========= */
async function buildBaseKey(imgVariant='PD'){
  const htmlHash = await getHtmlHash();
  const imgHash  = await getImageHash(imgVariant);

  const parts = [];
  if (htmlHash) parts.push(concatBytes(new Uint8Array([0x48]), htmlHash)); // 'H'
  if (imgHash)  parts.push(concatBytes(new Uint8Array([0x49]), imgHash)); // 'I'

  if (parts.length === 0) throw new Error(t('err_no_key'));

  const joined = concatBytes(...parts);
  const baseKey = await sha256Bytes(joined);
  const extra = enc.encode('EC2:' + (htmlHash?'H':'') + (imgHash?'I':''));
  return { baseKey, extra };
}

async function deriveAesKey(baseKey, saltBytes, extraBytes){
  const total = concatBytes(baseKey, saltBytes, extraBytes);
  const keyBytes = await sha256Bytes(total);
  return await crypto.subtle.importKey('raw', keyBytes, {name:'AES-GCM'}, false, ['encrypt','decrypt']);
}

async function encryptAesGcm(plainBytes, key, iv) {
  return new Uint8Array(await crypto.subtle.encrypt({ name: "AES-GCM", iv }, key, plainBytes));
}
async function decryptAesGcm(cipherBytes, key, iv) {
  return new Uint8Array(await crypto.subtle.decrypt({ name: "AES-GCM", iv }, key, cipherBytes));
}

function randomBytes(n){
  const u = new Uint8Array(n);
  crypto.getRandomValues(u);
  return u;
}

/* ========= UI logic ========= */
function updateState(){
  const hasKey = !!urlInput.value.trim() || !!imgInput.files[0];
  const hasMsg = !!msgInput.value.trim();
  encryptBtn.disabled = !(hasKey && hasMsg);
  decryptBtn.disabled = !(hasKey && hasMsg);

  if (!hasKey) setStatus(t('hint_key'));
  else if (!hasMsg) setStatus(t('hint_msg'));
  else setStatus(t('ready'));
}
urlInput.addEventListener('input', updateState);
imgInput.addEventListener('change', updateState);
msgInput.addEventListener('input', updateState);

encryptBtn.addEventListener('click', async ()=>{
  try{
    setStatus(t('encrypting'));
    const msg = msgInput.value;
    if (!msg.trim()) throw new Error(t('err_empty_msg'));
    const { baseKey, extra } = await buildBaseKey('PD');
    const salt = randomBytes(16);
    const iv   = randomBytes(12);
    const key  = await deriveAesKey(baseKey, salt, extra);
    const ct   = await encryptAesGcm(enc.encode(msg), key, iv);
    const packed = concatBytes(salt, iv, ct);
    const b64 = b64encode(packed);
    msgInput.value = b64;
    msgInput.focus();
    msgInput.select();
    setStatus(t('done_encrypt'));
    updateState();
  }catch(e){
    setStatus(e && e.message ? e.message : String(e), true);
  }
});

decryptBtn.addEventListener('click', async ()=>{
  try{
    setStatus(t('decrypting'));
    const b64 = msgInput.value.trim();
    if (!b64) throw new Error(t('err_empty_msg'));
    let packed;
    try{ packed = b64decode(b64); }catch(_){
      throw new Error(t('err_bad_format'));
    }
    if (packed.length < 16+12+1) throw new Error(t('err_bad_format'));
    const salt = packed.subarray(0,16);
    const iv   = packed.subarray(16,28);
    const ct   = packed.subarray(28);

    const variants = ['PD','DH','RAW'];
    for (const v of variants){
      try{
        const { baseKey, extra } = await buildBaseKey(v);
        const key = await deriveAesKey(baseKey, salt, extra);
        const pt  = await decryptAesGcm(ct, key, iv);
        const text = dec.decode(pt);
        msgInput.value = text;
        msgInput.focus();
        msgInput.select();
        setStatus(t('done_decrypt'));
        updateState();
        return;
      }catch(_){}
    }
    throw new Error(t('err_decrypt'));
  }catch(e){
    setStatus(e && e.message ? e.message : String(e), true);
  }
});

updateState();

/* ========= SW ========= */
if ('serviceWorker' in navigator){
  navigator.serviceWorker.register('./sw.js?v=1.0.9', { scope:'./', updateViaCache:'none' })
    .catch(()=>{});
  navigator.serviceWorker.addEventListener('controllerchange', ()=>{
    if (window.__ec_reloaded) return;
    window.__ec_reloaded = true;
    location.reload();
  });
}
</script>
</body>
</html>